<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_65) on Fri Jan 03 21:24:24 CET 2014 -->
<TITLE>
NonoSolver
</TITLE>

<META NAME="date" CONTENT="2014-01-03">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="NonoSolver";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/NonoSolver.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../service/PlayGame.html" title="class in service"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?service/NonoSolver.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="NonoSolver.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
service</FONT>
<BR>
Class NonoSolver</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>service.NonoSolver</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>de.feu.propra.nonogramme.interfaces.INonogramSolver</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>NonoSolver</B><DT>extends java.lang.Object<DT>implements de.feu.propra.nonogramme.interfaces.INonogramSolver</DL>
</PRE>

<P>
Klasse, die das Lösen eines Nonogramms übernimmt. Um eine Lösung zu erhalten
 muss nur <A HREF="../service/NonoSolver.html#getSolution()"><CODE>getSolution()</CODE></A> aufgerufen werden und gegebenenfalls
 <A HREF="../service/NonoSolver.html#solveState"><CODE>solveState</CODE></A> betrachtet werden. Der Algorithmus läuft in zwei Stufen
 ab.Es wird erst versucht das Rätsel logisch zu lösen. Wenn dies nicht
 ausreicht, wird ein Feld geraten und wieder logisch nach der Lösung gesucht.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>csgt</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;char[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#matrix">matrix</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Die Matrix mit dem aktuellen Stand der Lösung.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../models/Riddle.html" title="class in models">Riddle</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#riddle">riddle</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Das zu lösende <A HREF="../models/Riddle.html" title="class in models"><CODE>Riddle</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../service/RiddleService.html" title="class in service">RiddleService</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#riddleLoader">riddleLoader</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zu nutzende <A HREF="../service/RiddleService.html" title="class in service"><CODE>RiddleService</CODE></A></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;java.util.ArrayList&lt;char[][]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#solutionsFromGuising">solutionsFromGuising</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lösungen, die beim raten der Lösung gefunden wurden.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../models/SolveStateEnum.html" title="enum in models">SolveStateEnum</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#solveState">solveState</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Der Status beim Lösen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;java.util.LinkedList&lt;<A HREF="../models/StackHolder.html" title="class in models">StackHolder</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#stacks">stacks</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Liste der StackHolder, die bei jedem Raten hinzugefügt werden.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../service/NonoSolver.html#NonoSolver()">NonoSolver</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Konstruktor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../service/NonoSolver.html#NonoSolver(char[][], models.Riddle)">NonoSolver</A></B>(char[][]&nbsp;matrix,
           <A HREF="../models/Riddle.html" title="class in models">Riddle</A>&nbsp;riddle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Konstruktor.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#changeLastStacksMember()">changeLastStacksMember</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Holt den zuletzt hinzugefügten Stackholder und ändert die Farbe, falls die
 neue Farbe in der Reihe und der Spalte, in der der StackHolder gesetzt
 wurde, vorkommt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkBlocksIfIndexIsOk(models.Column)">checkBlocksIfIndexIsOk</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prüft für jeden Block in dieser Spalte, ob es einen Block in der
 jeweiligen Reihe gibt, der sich mit diesem überschneidet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkBlocksIfIndexIsOk(models.Row)">checkBlocksIfIndexIsOk</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prüft für jeden Block in dieser Reihe, ob es einen Block in der jeweiligen
 Spalte gibt, der sich mit diesem überschneidet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkByBlock()">checkByBlock</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ruft mehrere Methoden auf, die versuchen das Rätsel auf Blockebene zu
 lösen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkColorBelongingToBlock(models.Column)">checkColorBelongingToBlock</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prüft, ob eine gesetzte Farbe zu einem Block gehört.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkColorBelongingToBlock(models.Row)">checkColorBelongingToBlock</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prüft, ob eine gesetzte Farbe zu einem Block gehört.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkEmptyBelongingToBlock(models.Column)">checkEmptyBelongingToBlock</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Überprüft, ob ein Leerfeld zu einem Block gehört.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkEmptyBelongingToBlock(models.Row)">checkEmptyBelongingToBlock</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Überprüft, ob ein Leerfeld zu einem Block gehört.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkEmptyInBetweenBlock(models.Column)">checkEmptyInBetweenBlock</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wenn es ein - innerhalb von <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> und
 <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> gibt, wird überprüft, ob davor oder danach noch
 genug Platz für den Block ist, wenn nicht können die Werte neu gesetzt
 werden</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkEmptyInBetweenBlock(models.Row)">checkEmptyInBetweenBlock</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wenn es ein '-' innerhalb von minIndex und maxIndex gibt, wird überprüft,
 ob davor oder danach noch genug Platz für den Block ist.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkIfEntriesNotSetInBlock(models.Column)">checkIfEntriesNotSetInBlock</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testet, ob Felder innerhalb von Blöcken gesetzt werden können.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkIfEntriesNotSetInBlock(models.Row)">checkIfEntriesNotSetInBlock</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testet, ob Felder innerhalb von Blöcken gesetzt werden können.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkSizesBeforeAndAfterEmptyInBlockRange(models.Block, int)">checkSizesBeforeAndAfterEmptyInBlockRange</A></B>(<A HREF="../models/Block.html" title="class in models">Block</A>&nbsp;block,
                                          int&nbsp;columnInt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prüft, ob nach bzw. vor dem leeren Feld noch genug Platz für den Block
 ist. falls nicht, wird minIndex bzw maxIndex angepasst.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkStarBelongingToBlock(models.Column)">checkStarBelongingToBlock</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Überprüft, ob ein "*" nur zu einem Block gehört.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#checkStarBelongingToBlock(models.Row)">checkStarBelongingToBlock</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Überprüft, ob ein "*" nur zu einem Block gehört.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#fillAreaInColumnWithChar(int, int, int, char)">fillAreaInColumnWithChar</A></B>(int&nbsp;columnIndex,
                         int&nbsp;rowBegin,
                         int&nbsp;rowEnd,
                         char&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Füllt den Bereich in der column zwischen rowBegin (inklusive) und rowEnd
 (exklusive) mit dem char c.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#fillAreaInRowWithChar(int, int, int, char)">fillAreaInRowWithChar</A></B>(int&nbsp;rowIndex,
                      int&nbsp;columnBegin,
                      int&nbsp;columnEnd,
                      char&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Füllt den Bereich in der row zwischen columnBegin (inklusive) und
 columnEnd (exklusive) mit dem char c.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#fillEntriesFromBlockIntoMatrix(models.Column)">fillEntriesFromBlockIntoMatrix</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schreibt die bereits gesetzten Felder des Blocks, die in
 <A HREF="../models/Block.html#indeces"><CODE>Block.indeces</CODE></A> in die Matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#fillEntriesFromBlockIntoMatrix(models.Row)">fillEntriesFromBlockIntoMatrix</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schreibt die bereits gesetzten Felder des Blocks, die in
 <A HREF="../models/Block.html#indeces"><CODE>Block.indeces</CODE></A> gespeichert sind, in die Matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#fillIfMinMaxEqualToHowMany(models.Column)">fillIfMinMaxEqualToHowMany</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Füllt den Bereich zwischen <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> und
 <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> des Blockes, falls die Differenz gleich der Größe
 des Blocks (<A HREF="../models/Block.html#howMany"><CODE>Block.howMany</CODE></A>) ist</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#fillIfMinMaxEqualToHowMany(models.Row)">fillIfMinMaxEqualToHowMany</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Füllt den Bereich zwischen <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> und
 <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> des Blockes, falls die Differenz gleich der Größe
 des Blocks (<A HREF="../models/Block.html#howMany"><CODE>Block.howMany</CODE></A>) ist</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#fillWithEmptyAfterGone(models.Column)">fillWithEmptyAfterGone</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wenn ein Block in dieser Reihe gesetzt ist (<A HREF="../models/Block.html#gone"><CODE>Block.gone</CODE></A> == true),
 wird davor bzw. danach ein Leerfeld gesetzt wenn der vorherige bzw.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#fillWithEmptyAfterGone(models.Row)">fillWithEmptyAfterGone</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wenn ein Block in dieser Reihe gesetzt ist (<A HREF="../models/Block.html#gone"><CODE>Block.gone</CODE></A> == true),
 wird davor bzw. danach ein Leerfeld gesetzt wenn der vorherige bzw.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#fillWithFree(boolean, int)">fillWithFree</A></B>(boolean&nbsp;forRow,
             int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Füllt alle '*' der Reihe oder Spalte mit '-'.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;java.util.ArrayList&lt;<A HREF="../models/Column.html" title="class in models">Column</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#getColumns()">getColumns</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gibt alle Spalten des Rätsels zurück.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#getEmail()">getEmail</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#getMatrNr()">getMatrNr</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#getMaxEndIndexOfBlock(java.util.ArrayList, int, int)">getMaxEndIndexOfBlock</A></B>(java.util.ArrayList&lt;<A HREF="../models/Block.html" title="class in models">Block</A>&gt;&nbsp;blocks,
                      int&nbsp;indexOfBlock,
                      int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Berechnet den maximalen Index für einen Block, indem die Größen der
 nachfolgenden Blöcke unter Berücksichtigung etwaiger Zwischenräume addiert
 werden.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#getMinStartIndexOfBlock(java.util.ArrayList, int, int)">getMinStartIndexOfBlock</A></B>(java.util.ArrayList&lt;<A HREF="../models/Block.html" title="class in models">Block</A>&gt;&nbsp;blocks,
                        int&nbsp;indexOfBlock,
                        int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Berechnet den minimalen Startindex eines Blockes, indem die Größen der
 vorherigen Blöcke unter Berücksichtigung etwaiger Zwischenräume addiert
 werden.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#getName()">getName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;java.util.ArrayList&lt;<A HREF="../models/Row.html" title="class in models">Row</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#getRows()">getRows</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gibt alle Reihen des Rätsels zurück.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#getSolution()">getSolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../models/SolveStateEnum.html" title="enum in models">SolveStateEnum</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#getSolveState()">getSolveState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#getStarCountInRiddle()">getStarCountInRiddle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gibt die Anzahl der nicht belegten Felder zurück.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#handle()">handle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Steuert den Lösungsprozess.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;java.util.LinkedList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#initializeBlockList(models.Block)">initializeBlockList</A></B>(<A HREF="../models/Block.html" title="class in models">Block</A>&nbsp;block)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Erstellt die erste Möglichkeit den Block zu setzten.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#isColorInThisRowAndColumn(int, int, int)">isColorInThisRowAndColumn</A></B>(int&nbsp;rowInt,
                          int&nbsp;columnInt,
                          int&nbsp;indexOfColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Überprüft, ob es in der Reihe und der Spalte einen Block mit der Farbe
 gibt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#isSolutionOk()">isSolutionOk</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Überprüft die Matrix auf Korrektheit.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#moveBlocksInList(java.util.LinkedList, java.util.LinkedList, java.util.LinkedList)">moveBlocksInList</A></B>(java.util.LinkedList&lt;java.lang.String&gt;&nbsp;workingList,
                 java.util.LinkedList&lt;java.lang.String&gt;&nbsp;firstList,
                 java.util.LinkedList&lt;java.lang.Integer&gt;&nbsp;result)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verschiebt das letzte Zeichen (immer ein -) von der letzten an die erste
 Position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#openFile(java.lang.String)">openFile</A></B>(java.lang.String&nbsp;arg0)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#overlapBlocks(models.Column)">overlapBlocks</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Erstellt alle Möglichkeiten, den Block innerhalb von minIndex und maxIndex
 zu platzieren und setzt die Felder in der Matrix, die bei allen
 Möglichkeiten gesetzt sind.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#overlapBlocks(models.Row)">overlapBlocks</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Erstellt alle Möglichkeiten, den Block innerhalb von
 <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> und <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> zu platzieren und setzt
 die Felder in der Matrix, die bei allen Möglichkeiten gesetzt sind.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#setFirstStarToSomething()">setFirstStarToSomething</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setzt den ersten "*" in der Matrix auf "-".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#setupBlocks()">setupBlocks</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setzt die initialen Werte für minIndex und maxIndex bei den Blöcken.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#setupBlocksInRowAndColumn(java.util.ArrayList, int)">setupBlocksInRowAndColumn</A></B>(java.util.ArrayList&lt;<A HREF="../models/Block.html" title="class in models">Block</A>&gt;&nbsp;blocks,
                          int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setzt die initialen Werte für minIndex und maxIndex für alle Blöcke in
 blocks.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#setupMatrix()">setupMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Erstellt eine neue Matrix mit der Breite und Höhe des Rätsels und füllt
 diese mit '*'.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#showMatrix()">showMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Display the matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;java.lang.StringBuilder</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#showRow(java.lang.StringBuilder, int)">showRow</A></B>(java.lang.StringBuilder&nbsp;out,
        int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Row with the index i of the current matrix as String.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../models/SolveStateEnum.html" title="enum in models">SolveStateEnum</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#solve()">solve</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ruft die eigentlichen Methoden zum Lösen solange auf, bis sich keine
 Veränderung mehr in einem Durchlauf ergibt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#updateBlocksAfterThisBlock(java.util.ArrayList, int, models.Block, int)">updateBlocksAfterThisBlock</A></B>(java.util.ArrayList&lt;<A HREF="../models/Block.html" title="class in models">Block</A>&gt;&nbsp;blocks,
                           int&nbsp;blockIndex,
                           <A HREF="../models/Block.html" title="class in models">Block</A>&nbsp;block,
                           int&nbsp;maxIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setzt <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> der vorherigen Blöcke neu, falls
 <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> des vorherigen Blocks <= <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> des
 Blocks ist.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#updateBlocksBeforeThisBlock(java.util.ArrayList, int, models.Block, int)">updateBlocksBeforeThisBlock</A></B>(java.util.ArrayList&lt;<A HREF="../models/Block.html" title="class in models">Block</A>&gt;&nbsp;blocks,
                            int&nbsp;blockIndex,
                            <A HREF="../models/Block.html" title="class in models">Block</A>&nbsp;block,
                            int&nbsp;minIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setzt <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> der vorherigen Blöcke neu, falls
 <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> des vorherigen Blocks >= <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> des
 Blocks ist.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#updateMinAndMaxIndexOfBlocks(models.Column)">updateMinAndMaxIndexOfBlocks</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setzt <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A>/<A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> von Blöcken neu, falls
 der vorherige oder nachfolgende gone ist.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#updateMinAndMaxIndexOfBlocks(models.Row)">updateMinAndMaxIndexOfBlocks</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setzt <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A>/<A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> von Blöcken neu, falls
 der vorherige bzw. nachfolgende gone ist.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#updateMinAndMaxIndexOfBlocks2(models.Column)">updateMinAndMaxIndexOfBlocks2</A></B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Geht durch die Blöcke der Reihe.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#updateMinAndMaxIndexOfBlocks2(models.Row)">updateMinAndMaxIndexOfBlocks2</A></B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Geht durch die Blöcke der Reihe.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../service/NonoSolver.html#writeCharInMatrix(int, char, int)">writeCharInMatrix</A></B>(int&nbsp;rowIndex,
                  char&nbsp;c,
                  int&nbsp;columnIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Füllt die Stelle in der Matrix.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="riddleLoader"><!-- --></A><H3>
riddleLoader</H3>
<PRE>
private <A HREF="../service/RiddleService.html" title="class in service">RiddleService</A> <B>riddleLoader</B></PRE>
<DL>
<DD>Zu nutzende <A HREF="../service/RiddleService.html" title="class in service"><CODE>RiddleService</CODE></A>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="riddle"><!-- --></A><H3>
riddle</H3>
<PRE>
private <A HREF="../models/Riddle.html" title="class in models">Riddle</A> <B>riddle</B></PRE>
<DL>
<DD>Das zu lösende <A HREF="../models/Riddle.html" title="class in models"><CODE>Riddle</CODE></A>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="matrix"><!-- --></A><H3>
matrix</H3>
<PRE>
private char[][] <B>matrix</B></PRE>
<DL>
<DD>Die Matrix mit dem aktuellen Stand der Lösung.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="solveState"><!-- --></A><H3>
solveState</H3>
<PRE>
private <A HREF="../models/SolveStateEnum.html" title="enum in models">SolveStateEnum</A> <B>solveState</B></PRE>
<DL>
<DD>Der Status beim Lösen.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="solutionsFromGuising"><!-- --></A><H3>
solutionsFromGuising</H3>
<PRE>
java.util.ArrayList&lt;char[][]&gt; <B>solutionsFromGuising</B></PRE>
<DL>
<DD>Lösungen, die beim raten der Lösung gefunden wurden.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="stacks"><!-- --></A><H3>
stacks</H3>
<PRE>
java.util.LinkedList&lt;<A HREF="../models/StackHolder.html" title="class in models">StackHolder</A>&gt; <B>stacks</B></PRE>
<DL>
<DD>Liste der StackHolder, die bei jedem Raten hinzugefügt werden.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="NonoSolver(char[][], models.Riddle)"><!-- --></A><H3>
NonoSolver</H3>
<PRE>
public <B>NonoSolver</B>(char[][]&nbsp;matrix,
                  <A HREF="../models/Riddle.html" title="class in models">Riddle</A>&nbsp;riddle)</PRE>
<DL>
<DD>Konstruktor. Er kann mit einer bereits gefüllten matrix und einem
 bestehenden Rätsel aufgerufen werden. Sonst wird eine matrix
 initialisiert.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>matrix</CODE> - .<DD><CODE>riddle</CODE> - .</DL>
</DL>
<HR>

<A NAME="NonoSolver()"><!-- --></A><H3>
NonoSolver</H3>
<PRE>
public <B>NonoSolver</B>()</PRE>
<DL>
<DD>Konstruktor.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getEmail()"><!-- --></A><H3>
getEmail</H3>
<PRE>
public java.lang.String <B>getEmail</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getEmail</CODE> in interface <CODE>de.feu.propra.nonogramme.interfaces.INonogramSolver</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMatrNr()"><!-- --></A><H3>
getMatrNr</H3>
<PRE>
public java.lang.String <B>getMatrNr</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getMatrNr</CODE> in interface <CODE>de.feu.propra.nonogramme.interfaces.INonogramSolver</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getName()"><!-- --></A><H3>
getName</H3>
<PRE>
public java.lang.String <B>getName</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getName</CODE> in interface <CODE>de.feu.propra.nonogramme.interfaces.INonogramSolver</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="openFile(java.lang.String)"><!-- --></A><H3>
openFile</H3>
<PRE>
public void <B>openFile</B>(java.lang.String&nbsp;arg0)
              throws java.io.IOException</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>openFile</CODE> in interface <CODE>de.feu.propra.nonogramme.interfaces.INonogramSolver</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getSolution()"><!-- --></A><H3>
getSolution</H3>
<PRE>
public char[][] <B>getSolution</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getSolution</CODE> in interface <CODE>de.feu.propra.nonogramme.interfaces.INonogramSolver</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="handle()"><!-- --></A><H3>
handle</H3>
<PRE>
private void <B>handle</B>()</PRE>
<DL>
<DD>Steuert den Lösungsprozess. Je nach Status von <A HREF="../service/NonoSolver.html#solveState"><CODE>solveState</CODE></A> wird
 <A HREF="../service/NonoSolver.html#solve()"><CODE>solve()</CODE></A>, <A HREF="../service/NonoSolver.html#setFirstStarToSomething()"><CODE>setFirstStarToSomething()</CODE></A> oder
 <A HREF="../service/NonoSolver.html#changeLastStacksMember()"><CODE>changeLastStacksMember()</CODE></A> aufgerufen oder die Methode abgebrochen.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="solve()"><!-- --></A><H3>
solve</H3>
<PRE>
private <A HREF="../models/SolveStateEnum.html" title="enum in models">SolveStateEnum</A> <B>solve</B>()</PRE>
<DL>
<DD>Ruft die eigentlichen Methoden zum Lösen solange auf, bis sich keine
 Veränderung mehr in einem Durchlauf ergibt. Dann wird der
 <A HREF="../service/NonoSolver.html#solveState"><CODE>solveState</CODE></A> entweder auf <A HREF="../models/SolveStateEnum.html#MUST_GUESS"><CODE>SolveStateEnum.MUST_GUESS</CODE></A>
 gesetzt, falls noch '*' in der matrix sind. Anderenfalls auf
 <A HREF="../models/SolveStateEnum.html#SOLVED"><CODE>SolveStateEnum.SOLVED</CODE></A> wenn der Stack leer ist oder auf
 <A HREF="../models/SolveStateEnum.html#FOUND_SOLUTION_WITH_STACK"><CODE>SolveStateEnum.FOUND_SOLUTION_WITH_STACK</CODE></A> falls im Stack
 Stackholder sind.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>solveState:</DL>
</DD>
</DL>
<HR>

<A NAME="isSolutionOk()"><!-- --></A><H3>
isSolutionOk</H3>
<PRE>
private boolean <B>isSolutionOk</B>()</PRE>
<DL>
<DD>Überprüft die Matrix auf Korrektheit.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true wenn die Matrix korrekt ist.</DL>
</DD>
</DL>
<HR>

<A NAME="changeLastStacksMember()"><!-- --></A><H3>
changeLastStacksMember</H3>
<PRE>
private boolean <B>changeLastStacksMember</B>()</PRE>
<DL>
<DD>Holt den zuletzt hinzugefügten Stackholder und ändert die Farbe, falls die
 neue Farbe in der Reihe und der Spalte, in der der StackHolder gesetzt
 wurde, vorkommt. Falls dies nicht der Fall ist, wird die nächste Farbe
 genommen.Das Riddle und die Matrix werden auf den Stand, der im
 Stackholder gespeichert ist zurückgesetzt. Falls alle Farben getestet
 wurden, wird der Stackholder entfernt und diese Methode nochmal
 aufgerufen, um den vorherigen Stackholder zu ändern.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>false, wenn stacks null oder leer ist, also alle Möglichkeiten
         getestet wurden.</DL>
</DD>
</DL>
<HR>

<A NAME="setFirstStarToSomething()"><!-- --></A><H3>
setFirstStarToSomething</H3>
<PRE>
private void <B>setFirstStarToSomething</B>()
                              throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Setzt den ersten "*" in der Matrix auf "-". Des weiteren wird ein
 StackHolder-Objekt angelegt, um den Status des Lösungsweges zu speichern.
 Überprüft nun auch, ob es die Farbe, die geraten werden soll, in der Reihe
 und Spalte gibt.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="checkByBlock()"><!-- --></A><H3>
checkByBlock</H3>
<PRE>
private void <B>checkByBlock</B>()
                   throws <A HREF="../excetions/NotSolvableException.html" title="class in excetions">NotSolvableException</A>,
                          <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Ruft mehrere Methoden auf, die versuchen das Rätsel auf Blockebene zu
 lösen. Dabei wird der minIndex und maxIndex der Blöcke möglichst weit
 eingeschränkt, um bei der Methode <A HREF="../service/NonoSolver.html#overlapBlocks(models.Row)"><CODE>overlapBlocks(Row)</CODE></A> viele
 überlappende Bereiche zu haben. Es wird auch versucht, Felder (leer, mit
 Farbe gesetzt oder ungesetzt) bestimmten Blöcken zuzuordnet, um dann
 weiter zu reagieren.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/NotSolvableException.html" title="class in excetions">NotSolvableException</A></CODE>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="checkBlocksIfIndexIsOk(models.Row)"><!-- --></A><H3>
checkBlocksIfIndexIsOk</H3>
<PRE>
private void <B>checkBlocksIfIndexIsOk</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</PRE>
<DL>
<DD>Prüft für jeden Block in dieser Reihe, ob es einen Block in der jeweiligen
 Spalte gibt, der sich mit diesem überschneidet. Dabei wird jeder Block in
 jeder Splate zwischen minIndex und maxIndex betrachtet. Wenn es keinen
 Block gibt, kann unter Vorraussetzungen minIndex oder maxIndex geändert
 werden.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - Reihe.</DL>
</DD>
</DL>
<HR>

<A NAME="checkBlocksIfIndexIsOk(models.Column)"><!-- --></A><H3>
checkBlocksIfIndexIsOk</H3>
<PRE>
private void <B>checkBlocksIfIndexIsOk</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</PRE>
<DL>
<DD>Prüft für jeden Block in dieser Spalte, ob es einen Block in der
 jeweiligen Reihe gibt, der sich mit diesem überschneidet. Dabei wird jeder
 Block in jeder Splate zwischen minIndex und maxIndex betrachtet. Wenn es
 keinen Block gibt, kann unter Vorraussetzungen minIndex oder maxIndex
 geändert werden.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - Spalte
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="isColorInThisRowAndColumn(int, int, int)"><!-- --></A><H3>
isColorInThisRowAndColumn</H3>
<PRE>
private boolean <B>isColorInThisRowAndColumn</B>(int&nbsp;rowInt,
                                          int&nbsp;columnInt,
                                          int&nbsp;indexOfColor)</PRE>
<DL>
<DD>Überprüft, ob es in der Reihe und der Spalte einen Block mit der Farbe
 gibt.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rowInt</CODE> - Reihenindex<DD><CODE>columnInt</CODE> - Spaltenindex<DD><CODE>indexOfColor</CODE> - Farbindex aus riddle.getColours()
<DT><B>Returns:</B><DD>true, falls in Reihe und Spalte die Farbe in einem Block vorkommt.</DL>
</DD>
</DL>
<HR>

<A NAME="checkStarBelongingToBlock(models.Row)"><!-- --></A><H3>
checkStarBelongingToBlock</H3>
<PRE>
private void <B>checkStarBelongingToBlock</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)
                                throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Überprüft, ob ein "*" nur zu einem Block gehört. Falls dies der Fall ist,
 wird überprüft, ob row.getMaxEntries() - row.getEntriesSet() - starCount
 == 0 ist. Dies bedeutet, dass nur noch ein Farbfeld zu setzen ist und es
 mit der Farbe des Blocks gesetzt werden kann.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="checkColorBelongingToBlock(models.Row)"><!-- --></A><H3>
checkColorBelongingToBlock</H3>
<PRE>
private void <B>checkColorBelongingToBlock</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)
                                 throws <A HREF="../excetions/NotSolvableException.html" title="class in excetions">NotSolvableException</A></PRE>
<DL>
<DD>Prüft, ob eine gesetzte Farbe zu einem Block gehört. Wenn ja wird der
 Index in indeces von Block geschrieben und die maximale und minimale
 Ausdehnung geändert.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/NotSolvableException.html" title="class in excetions">NotSolvableException</A></CODE> - Wenn die gesetzte Farbe zu keinem Block gehört</DL>
</DD>
</DL>
<HR>

<A NAME="checkColorBelongingToBlock(models.Column)"><!-- --></A><H3>
checkColorBelongingToBlock</H3>
<PRE>
private void <B>checkColorBelongingToBlock</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)
                                 throws <A HREF="../excetions/NotSolvableException.html" title="class in excetions">NotSolvableException</A></PRE>
<DL>
<DD>Prüft, ob eine gesetzte Farbe zu einem Block gehört. Wenn ja wird der
 Index in indeces von Block geschrieben und die maximale und minimale
 Ausdehnung geändert.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/NotSolvableException.html" title="class in excetions">NotSolvableException</A></CODE> - Wenn die gesetzte Farbe zu keinem Block gehört.</DL>
</DD>
</DL>
<HR>

<A NAME="checkStarBelongingToBlock(models.Column)"><!-- --></A><H3>
checkStarBelongingToBlock</H3>
<PRE>
private void <B>checkStarBelongingToBlock</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)
                                throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Überprüft, ob ein "*" nur zu einem Block gehört. Falls dies der Fall ist,
 wird überprüft, ob row.getMaxEntries() - row.getEntriesSet() - starCount)
 == 0 ist. Dies bedeutet, dass nur noch ein Farbfeld zu setzen ist und es
 mit der Farbe des Blocks gesetzt werden kann.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="checkEmptyBelongingToBlock(models.Row)"><!-- --></A><H3>
checkEmptyBelongingToBlock</H3>
<PRE>
private void <B>checkEmptyBelongingToBlock</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</PRE>
<DL>
<DD>Überprüft, ob ein Leerfeld zu einem Block gehört. Wenn der Index gleich
 dem minIndex oder maxIndex ist, werden diese in/dekrementiert. Wird in
 <A HREF="../service/NonoSolver.html#checkByBlock()"><CODE>checkByBlock()</CODE></A> aufgerufen.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="checkSizesBeforeAndAfterEmptyInBlockRange(models.Block, int)"><!-- --></A><H3>
checkSizesBeforeAndAfterEmptyInBlockRange</H3>
<PRE>
private void <B>checkSizesBeforeAndAfterEmptyInBlockRange</B>(<A HREF="../models/Block.html" title="class in models">Block</A>&nbsp;block,
                                                       int&nbsp;columnInt)</PRE>
<DL>
<DD>Prüft, ob nach bzw. vor dem leeren Feld noch genug Platz für den Block
 ist. falls nicht, wird minIndex bzw maxIndex angepasst. Wird in
 <A HREF="../service/NonoSolver.html#checkEmptyBelongingToBlock(models.Row)"><CODE>checkEmptyBelongingToBlock(Row)</CODE></A> und
 <A HREF="../service/NonoSolver.html#checkEmptyBelongingToBlock(models.Column)"><CODE>checkEmptyBelongingToBlock(Column)</CODE></A> aufgerufen.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>block</CODE> - .<DD><CODE>columnInt</CODE> - .</DL>
</DD>
</DL>
<HR>

<A NAME="checkEmptyBelongingToBlock(models.Column)"><!-- --></A><H3>
checkEmptyBelongingToBlock</H3>
<PRE>
private void <B>checkEmptyBelongingToBlock</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</PRE>
<DL>
<DD>Überprüft, ob ein Leerfeld zu einem Block gehört. Wenn der Index gleich
 dem minIndex oder maxIndex ist, werden diese in/dekrementiert. Wird in
 <A HREF="../service/NonoSolver.html#checkByBlock()"><CODE>checkByBlock()</CODE></A> aufgerufen.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="fillEntriesFromBlockIntoMatrix(models.Row)"><!-- --></A><H3>
fillEntriesFromBlockIntoMatrix</H3>
<PRE>
private void <B>fillEntriesFromBlockIntoMatrix</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)
                                     throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Schreibt die bereits gesetzten Felder des Blocks, die in
 <A HREF="../models/Block.html#indeces"><CODE>Block.indeces</CODE></A> gespeichert sind, in die Matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="fillEntriesFromBlockIntoMatrix(models.Column)"><!-- --></A><H3>
fillEntriesFromBlockIntoMatrix</H3>
<PRE>
private void <B>fillEntriesFromBlockIntoMatrix</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)
                                     throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Schreibt die bereits gesetzten Felder des Blocks, die in
 <A HREF="../models/Block.html#indeces"><CODE>Block.indeces</CODE></A> in die Matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="fillIfMinMaxEqualToHowMany(models.Row)"><!-- --></A><H3>
fillIfMinMaxEqualToHowMany</H3>
<PRE>
private void <B>fillIfMinMaxEqualToHowMany</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)
                                 throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Füllt den Bereich zwischen <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> und
 <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> des Blockes, falls die Differenz gleich der Größe
 des Blocks (<A HREF="../models/Block.html#howMany"><CODE>Block.howMany</CODE></A>) ist
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="fillIfMinMaxEqualToHowMany(models.Column)"><!-- --></A><H3>
fillIfMinMaxEqualToHowMany</H3>
<PRE>
private void <B>fillIfMinMaxEqualToHowMany</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)
                                 throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Füllt den Bereich zwischen <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> und
 <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> des Blockes, falls die Differenz gleich der Größe
 des Blocks (<A HREF="../models/Block.html#howMany"><CODE>Block.howMany</CODE></A>) ist
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="fillWithEmptyAfterGone(models.Row)"><!-- --></A><H3>
fillWithEmptyAfterGone</H3>
<PRE>
private void <B>fillWithEmptyAfterGone</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)
                             throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Wenn ein Block in dieser Reihe gesetzt ist (<A HREF="../models/Block.html#gone"><CODE>Block.gone</CODE></A> == true),
 wird davor bzw. danach ein Leerfeld gesetzt wenn der vorherige bzw.
 folgende Block dieselbe Farbe hat.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="fillWithEmptyAfterGone(models.Column)"><!-- --></A><H3>
fillWithEmptyAfterGone</H3>
<PRE>
private void <B>fillWithEmptyAfterGone</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)
                             throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Wenn ein Block in dieser Reihe gesetzt ist (<A HREF="../models/Block.html#gone"><CODE>Block.gone</CODE></A> == true),
 wird davor bzw. danach ein Leerfeld gesetzt wenn der vorherige bzw.
 folgende Block dieselbe Farbe hat.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="checkEmptyInBetweenBlock(models.Row)"><!-- --></A><H3>
checkEmptyInBetweenBlock</H3>
<PRE>
private void <B>checkEmptyInBetweenBlock</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)</PRE>
<DL>
<DD>Wenn es ein '-' innerhalb von minIndex und maxIndex gibt, wird überprüft,
 ob davor oder danach noch genug Platz für den Block ist. Wenn nicht können
 die Werte neu gesetzt werden
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="checkEmptyInBetweenBlock(models.Column)"><!-- --></A><H3>
checkEmptyInBetweenBlock</H3>
<PRE>
private void <B>checkEmptyInBetweenBlock</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</PRE>
<DL>
<DD>Wenn es ein - innerhalb von <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> und
 <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> gibt, wird überprüft, ob davor oder danach noch
 genug Platz für den Block ist, wenn nicht können die Werte neu gesetzt
 werden
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="checkIfEntriesNotSetInBlock(models.Row)"><!-- --></A><H3>
checkIfEntriesNotSetInBlock</H3>
<PRE>
private void <B>checkIfEntriesNotSetInBlock</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)
                                  throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Testet, ob Felder innerhalb von Blöcken gesetzt werden können. Z.B. wenn
 in <A HREF="../models/Block.html#indeces"><CODE>Block.indeces</CODE></A> 2 und 5 eingetragen sind, müssen 3 und 4 auch
 gesetzt werden.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="checkIfEntriesNotSetInBlock(models.Column)"><!-- --></A><H3>
checkIfEntriesNotSetInBlock</H3>
<PRE>
private void <B>checkIfEntriesNotSetInBlock</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)
                                  throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Testet, ob Felder innerhalb von Blöcken gesetzt werden können. Z.B. wenn
 in <A HREF="../models/Block.html#indeces"><CODE>Block.indeces</CODE></A> 2 und 5 eingetragen sind, müssen 3 und 4 auch
 gesetzt werden.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="updateMinAndMaxIndexOfBlocks(models.Row)"><!-- --></A><H3>
updateMinAndMaxIndexOfBlocks</H3>
<PRE>
private void <B>updateMinAndMaxIndexOfBlocks</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)
                                   throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Setzt <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A>/<A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> von Blöcken neu, falls
 der vorherige bzw. nachfolgende gone ist. Somit schränkt sich der Bereich,
 in dem der Block gesetzt werden kann, ein. Überprüft auch, ob bei nicht
 fertigen Blöcken das nächste/vorherige von maxIndex/minIndex gleich der
 Blockfarbe ist und passt dann die Werte an.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="updateMinAndMaxIndexOfBlocks2(models.Row)"><!-- --></A><H3>
updateMinAndMaxIndexOfBlocks2</H3>
<PRE>
private void <B>updateMinAndMaxIndexOfBlocks2</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)
                                    throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Geht durch die Blöcke der Reihe. Wenn es mehr als einen Block gibt, werden
 immer zwei aufeinander folgende Blöcke überprüft, ob der
 <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> - <A HREF="../models/Block.html#howMany"><CODE>Block.howMany</CODE></A> des 2. Blocks kleiner ist,
 als der <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> des ersten Blocks. Dann muss der Index des
 1. Blocks angepasst werden. Gleiches geschieht für den
 <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> , nur dass hier der 2. Block angepasst wird.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="updateMinAndMaxIndexOfBlocks2(models.Column)"><!-- --></A><H3>
updateMinAndMaxIndexOfBlocks2</H3>
<PRE>
private void <B>updateMinAndMaxIndexOfBlocks2</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</PRE>
<DL>
<DD>Geht durch die Blöcke der Reihe. Wenn es mehr als einen Block gibt, werden
 immer zwei aufeinander folgende Blöcke überprüft, ob der
 <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> - der Größe des 2. Blocks kleiner ist, als der
 <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> des ersten Blocks. Dann muss der Index des 1.
 Blocks angepasst werden. Gleiches geschieht für den <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A>
 , nur dass hier der 2. Block angepasst wird.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="updateBlocksBeforeThisBlock(java.util.ArrayList, int, models.Block, int)"><!-- --></A><H3>
updateBlocksBeforeThisBlock</H3>
<PRE>
private void <B>updateBlocksBeforeThisBlock</B>(java.util.ArrayList&lt;<A HREF="../models/Block.html" title="class in models">Block</A>&gt;&nbsp;blocks,
                                         int&nbsp;blockIndex,
                                         <A HREF="../models/Block.html" title="class in models">Block</A>&nbsp;block,
                                         int&nbsp;minIndex)</PRE>
<DL>
<DD>Setzt <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> der vorherigen Blöcke neu, falls
 <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> des vorherigen Blocks >= <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> des
 Blocks ist. Wird aufgerufen, wenn ein Block abgeschlossen wurde.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>blocks</CODE> - zu überprüfende Blöcke<DD><CODE>blockIndex</CODE> - index des Blocks, dessen Vorgänger geprüft werden sollen<DD><CODE>block</CODE> - Block, dessen Vorgänger geprüft werden sollen<DD><CODE>minIndex</CODE> - minIndex des Blocks</DL>
</DD>
</DL>
<HR>

<A NAME="updateBlocksAfterThisBlock(java.util.ArrayList, int, models.Block, int)"><!-- --></A><H3>
updateBlocksAfterThisBlock</H3>
<PRE>
private void <B>updateBlocksAfterThisBlock</B>(java.util.ArrayList&lt;<A HREF="../models/Block.html" title="class in models">Block</A>&gt;&nbsp;blocks,
                                        int&nbsp;blockIndex,
                                        <A HREF="../models/Block.html" title="class in models">Block</A>&nbsp;block,
                                        int&nbsp;maxIndex)</PRE>
<DL>
<DD>Setzt <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> der vorherigen Blöcke neu, falls
 <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> des vorherigen Blocks <= <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> des
 Blocks ist. Wird aufgerufen, wenn ein Block abgeschlossen wurde.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>blocks</CODE> - zu überprüfende Blöcke<DD><CODE>blockIndex</CODE> - index des Blocks, dessen Nachfolger geprüft werden sollen<DD><CODE>block</CODE> - Block, dessen Nachfolger geprüft werden sollen<DD><CODE>maxIndex</CODE> - minIndex des Blocks</DL>
</DD>
</DL>
<HR>

<A NAME="updateMinAndMaxIndexOfBlocks(models.Column)"><!-- --></A><H3>
updateMinAndMaxIndexOfBlocks</H3>
<PRE>
private void <B>updateMinAndMaxIndexOfBlocks</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)</PRE>
<DL>
<DD>Setzt <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A>/<A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> von Blöcken neu, falls
 der vorherige oder nachfolgende gone ist. Somit schränkt sich der Bereich,
 in dem der Block gesetzt werden kann ein. Überprüft auch, ob bei nicht
 fertigen Blöcken das nächste/vorherige von maxIndex/minIndex gleich der
 Blockfarbe ist und passt dann die Werte an.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="overlapBlocks(models.Row)"><!-- --></A><H3>
overlapBlocks</H3>
<PRE>
private void <B>overlapBlocks</B>(<A HREF="../models/Row.html" title="class in models">Row</A>&nbsp;row)
                    throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Erstellt alle Möglichkeiten, den Block innerhalb von
 <A HREF="../models/Block.html#minIndex"><CODE>Block.minIndex</CODE></A> und <A HREF="../models/Block.html#maxIndex"><CODE>Block.maxIndex</CODE></A> zu platzieren und setzt
 die Felder in der Matrix, die bei allen Möglichkeiten gesetzt sind.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="initializeBlockList(models.Block)"><!-- --></A><H3>
initializeBlockList</H3>
<PRE>
private java.util.LinkedList&lt;java.lang.String&gt; <B>initializeBlockList</B>(<A HREF="../models/Block.html" title="class in models">Block</A>&nbsp;block)</PRE>
<DL>
<DD>Erstellt die erste Möglichkeit den Block zu setzten. Wird in
 <A HREF="../service/NonoSolver.html#overlapBlocks(models.Column)"><CODE>overlapBlocks(Column)</CODE></A> und <A HREF="../service/NonoSolver.html#overlapBlocks(models.Row)"><CODE>overlapBlocks(Row)</CODE></A> aufgerufen.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>block</CODE> - zu bearbeitende Block
<DT><B>Returns:</B><DD>LinkedList<String> mit der Startbesetzung der Blöcke</DL>
</DD>
</DL>
<HR>

<A NAME="overlapBlocks(models.Column)"><!-- --></A><H3>
overlapBlocks</H3>
<PRE>
private void <B>overlapBlocks</B>(<A HREF="../models/Column.html" title="class in models">Column</A>&nbsp;column)
                    throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Erstellt alle Möglichkeiten, den Block innerhalb von minIndex und maxIndex
 zu platzieren und setzt die Felder in der Matrix, die bei allen
 Möglichkeiten gesetzt sind.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setupMatrix()"><!-- --></A><H3>
setupMatrix</H3>
<PRE>
private void <B>setupMatrix</B>()</PRE>
<DL>
<DD>Erstellt eine neue Matrix mit der Breite und Höhe des Rätsels und füllt
 diese mit '*'.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setupBlocks()"><!-- --></A><H3>
setupBlocks</H3>
<PRE>
private void <B>setupBlocks</B>()</PRE>
<DL>
<DD>Setzt die initialen Werte für minIndex und maxIndex bei den Blöcken.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="moveBlocksInList(java.util.LinkedList, java.util.LinkedList, java.util.LinkedList)"><!-- --></A><H3>
moveBlocksInList</H3>
<PRE>
private void <B>moveBlocksInList</B>(java.util.LinkedList&lt;java.lang.String&gt;&nbsp;workingList,
                              java.util.LinkedList&lt;java.lang.String&gt;&nbsp;firstList,
                              java.util.LinkedList&lt;java.lang.Integer&gt;&nbsp;result)</PRE>
<DL>
<DD>Verschiebt das letzte Zeichen (immer ein -) von der letzten an die erste
 Position. Dann wird jede Position der workingList mit der Position in der
 firstList verglichen. Falls die Posiitonen nicht gleich sind wird die
 Position aus result gelöscht.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>workingList</CODE> - Liste, in der die Einträge geschoben werden<DD><CODE>firstList</CODE> - Vergleichsliste<DD><CODE>result</CODE> - Liste mit Positionen (aus firstList) die gesetzt werden können.</DL>
</DD>
</DL>
<HR>

<A NAME="getMinStartIndexOfBlock(java.util.ArrayList, int, int)"><!-- --></A><H3>
getMinStartIndexOfBlock</H3>
<PRE>
private int <B>getMinStartIndexOfBlock</B>(java.util.ArrayList&lt;<A HREF="../models/Block.html" title="class in models">Block</A>&gt;&nbsp;blocks,
                                    int&nbsp;indexOfBlock,
                                    int&nbsp;size)</PRE>
<DL>
<DD>Berechnet den minimalen Startindex eines Blockes, indem die Größen der
 vorherigen Blöcke unter Berücksichtigung etwaiger Zwischenräume addiert
 werden.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>blocks</CODE> - alle Blöcke der Reihe / Spalte<DD><CODE>indexOfBlock</CODE> - Index des zu betrachteten Blocks<DD><CODE>size</CODE> - Breite / Höhe des Rätsels
<DT><B>Returns:</B><DD>den neuen minIndex</DL>
</DD>
</DL>
<HR>

<A NAME="getMaxEndIndexOfBlock(java.util.ArrayList, int, int)"><!-- --></A><H3>
getMaxEndIndexOfBlock</H3>
<PRE>
private int <B>getMaxEndIndexOfBlock</B>(java.util.ArrayList&lt;<A HREF="../models/Block.html" title="class in models">Block</A>&gt;&nbsp;blocks,
                                  int&nbsp;indexOfBlock,
                                  int&nbsp;size)</PRE>
<DL>
<DD>Berechnet den maximalen Index für einen Block, indem die Größen der
 nachfolgenden Blöcke unter Berücksichtigung etwaiger Zwischenräume addiert
 werden.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>blocks</CODE> - alle Blöcke dieser Reihe/Spalte<DD><CODE>indexOfBlock</CODE> - Index des zu betrachteten Blocks.<DD><CODE>size</CODE> - Breite / Höhe des Rätsels
<DT><B>Returns:</B><DD>den neuen maxIndex</DL>
</DD>
</DL>
<HR>

<A NAME="showRow(java.lang.StringBuilder, int)"><!-- --></A><H3>
showRow</H3>
<PRE>
private java.lang.StringBuilder <B>showRow</B>(java.lang.StringBuilder&nbsp;out,
                                        int&nbsp;i)</PRE>
<DL>
<DD>Returns the Row with the index i of the current matrix as String.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>out</CODE> - String in den die Reihe geschriben wird.<DD><CODE>i</CODE> - 
<DT><B>Returns:</B><DD>eine Reihe in der Matrix als StringBuilder</DL>
</DD>
</DL>
<HR>

<A NAME="fillWithFree(boolean, int)"><!-- --></A><H3>
fillWithFree</H3>
<PRE>
private void <B>fillWithFree</B>(boolean&nbsp;forRow,
                          int&nbsp;index)</PRE>
<DL>
<DD>Füllt alle '*' der Reihe oder Spalte mit '-'. Kann aufgerufen werden, wenn
 eine Reihe gone ist.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>forRow</CODE> - Soll eine Reihe gefüllt werden.<DD><CODE>index</CODE> - Index der Reihe oder Spalte</DL>
</DD>
</DL>
<HR>

<A NAME="setupBlocksInRowAndColumn(java.util.ArrayList, int)"><!-- --></A><H3>
setupBlocksInRowAndColumn</H3>
<PRE>
private void <B>setupBlocksInRowAndColumn</B>(java.util.ArrayList&lt;<A HREF="../models/Block.html" title="class in models">Block</A>&gt;&nbsp;blocks,
                                       int&nbsp;size)</PRE>
<DL>
<DD>Setzt die initialen Werte für minIndex und maxIndex für alle Blöcke in
 blocks.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>blocks</CODE> - Blöcke der Reihe oder Spalte.<DD><CODE>size</CODE> - Höhe oder Breite des Rätsels.</DL>
</DD>
</DL>
<HR>

<A NAME="fillAreaInColumnWithChar(int, int, int, char)"><!-- --></A><H3>
fillAreaInColumnWithChar</H3>
<PRE>
private void <B>fillAreaInColumnWithChar</B>(int&nbsp;columnIndex,
                                      int&nbsp;rowBegin,
                                      int&nbsp;rowEnd,
                                      char&nbsp;c)
                               throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Füllt den Bereich in der column zwischen rowBegin (inklusive) und rowEnd
 (exklusive) mit dem char c.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>columnIndex</CODE> - <DD><CODE>rowBegin</CODE> - <DD><CODE>rowEnd</CODE> - <DD><CODE>c</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="fillAreaInRowWithChar(int, int, int, char)"><!-- --></A><H3>
fillAreaInRowWithChar</H3>
<PRE>
private void <B>fillAreaInRowWithChar</B>(int&nbsp;rowIndex,
                                   int&nbsp;columnBegin,
                                   int&nbsp;columnEnd,
                                   char&nbsp;c)
                            throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Füllt den Bereich in der row zwischen columnBegin (inklusive) und
 columnEnd (exklusive) mit dem char c.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rowIndex</CODE> - <DD><CODE>columnBegin</CODE> - <DD><CODE>columnEnd</CODE> - <DD><CODE>c</CODE> - 
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="writeCharInMatrix(int, char, int)"><!-- --></A><H3>
writeCharInMatrix</H3>
<PRE>
private void <B>writeCharInMatrix</B>(int&nbsp;rowIndex,
                               char&nbsp;c,
                               int&nbsp;columnIndex)
                        throws <A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></PRE>
<DL>
<DD>Füllt die Stelle in der Matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rowIndex</CODE> - Nummer der Reihe in der Matrix.<DD><CODE>c</CODE> - Farbe<DD><CODE>columnIndex</CODE> - rowIndex Nummer der Reihe in der Matrix.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../excetions/DataCollisionException.html" title="class in excetions">DataCollisionException</A></CODE> - falls an der Stelle bereits ein anderer char als c oder '*'
            steht.</DL>
</DD>
</DL>
<HR>

<A NAME="getStarCountInRiddle()"><!-- --></A><H3>
getStarCountInRiddle</H3>
<PRE>
private int <B>getStarCountInRiddle</B>()</PRE>
<DL>
<DD>Gibt die Anzahl der nicht belegten Felder zurück.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Anzahl der noch nicht belegten Felder in der Matrix</DL>
</DD>
</DL>
<HR>

<A NAME="getColumns()"><!-- --></A><H3>
getColumns</H3>
<PRE>
private java.util.ArrayList&lt;<A HREF="../models/Column.html" title="class in models">Column</A>&gt; <B>getColumns</B>()</PRE>
<DL>
<DD>Gibt alle Spalten des Rätsels zurück.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>alle Spalten</DL>
</DD>
</DL>
<HR>

<A NAME="getRows()"><!-- --></A><H3>
getRows</H3>
<PRE>
private java.util.ArrayList&lt;<A HREF="../models/Row.html" title="class in models">Row</A>&gt; <B>getRows</B>()</PRE>
<DL>
<DD>Gibt alle Reihen des Rätsels zurück.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>alle Reihen</DL>
</DD>
</DL>
<HR>

<A NAME="showMatrix()"><!-- --></A><H3>
showMatrix</H3>
<PRE>
private void <B>showMatrix</B>()</PRE>
<DL>
<DD>Display the matrix. TODO delete
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSolveState()"><!-- --></A><H3>
getSolveState</H3>
<PRE>
public <A HREF="../models/SolveStateEnum.html" title="enum in models">SolveStateEnum</A> <B>getSolveState</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the solveState</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/NonoSolver.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../service/PlayGame.html" title="class in service"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?service/NonoSolver.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="NonoSolver.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
